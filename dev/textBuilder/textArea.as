package textBuilder{	import flash.display.Sprite;	import flash.display.Shape;	//import flash.geom.Rectangle;	import flash.events.Event;	import flashx.textLayout.compose.StandardFlowComposer;	import flashx.textLayout.container.ContainerController;	import flashx.textLayout.container.ScrollPolicy;	//import flashx.textLayout.elements.InlineGraphicElement;	import flashx.textLayout.elements.InlineGraphicElementStatus;	import flashx.textLayout.elements.ParagraphElement;	import flashx.textLayout.elements.SpanElement;	import flashx.textLayout.elements.TextFlow;	import flashx.textLayout.conversion.*;	import flashx.textLayout.events.*;	import flashx.textLayout.edit.SelectionManager;	import fl.controls.UIScrollBar;	import fl.events.ScrollEvent;	import flash.events.Event;	public class textArea extends Sprite {		private var _textFlow:TextFlow;		//private var _inlineGraphic:InlineGraphicElement;		private var graphicTotal:Number = 0;		private var graphicLoaded:Number = 0;		private var graphicSizing:Number = 0;		private var txtXML:XML;		private var textSpace:Sprite;		private var myShape:Shape;		private var sl:UIScrollBar = new UIScrollBar();		//var sl:slider = new slider()		private var textHeight:int;		private var h:int		private var w:int		private var c:int		//private var boundsRect:Rectangle;		private var cont:ContainerController;		public function textArea(xml:XML) {			txtXML = new XML(xml);			//trace(txtXML);			addEventListener(Event.ADDED_TO_STAGE,buildTextSpace);		}		private function buildTextSpace(event:Event):void {			removeEventListener(Event.ADDED_TO_STAGE,buildTextSpace);			addEventListener(Event.REMOVED_FROM_STAGE, removedFromStage);			drawSpace();		}		private function drawSpace():void {			//if (getChildByName=="sl")			/*textSpace = new Sprite ();			addChild(textSpace);*/			w=375			h=400			c=15			myShape = new Shape();			myShape.graphics.lineStyle(1, 0x000000, .5, true);			myShape.graphics.beginFill(0xffffff,.5);			myShape.graphics.moveTo(c,0)			myShape.graphics.lineTo(w-c,0)			myShape.graphics.curveTo(w,0, w,c)			myShape.graphics.lineTo(w, h-c)			myShape.graphics.curveTo(w,h, w-c, h)			myShape.graphics.lineTo(c, h)			myShape.graphics.curveTo(0,h,0,h-c)			myShape.graphics.lineTo(0, c)			myShape.graphics.curveTo(0,0,c,0)			myShape.graphics.endFill();			addChild(myShape);			textSpace = new Sprite ();			addChild(textSpace);			beginFlow(txtXML) 		}		private function beginFlow(xml:XML):void {			_textFlow = new TextFlow();			_textFlow.flowComposer = new StandardFlowComposer();			_textFlow = TextConverter.importToFlow(xml,TextConverter.TEXT_LAYOUT_FORMAT);			_textFlow.fontFamily = "Helvetica";			_textFlow.fontLookup = "embeddedCFF";			//trace("From BeginFlow: \n"+TextConverter.export(_textFlow, TextConverter.TEXT_LAYOUT_FORMAT, ConversionType.XML_TYPE));			_textFlow.addEventListener(StatusChangeEvent.INLINE_GRAPHIC_STATUS_CHANGE,statusChangeHandler);			cont = new ContainerController(textSpace,(myShape.width-c),(myShape.height-c));			//cont.verticalScrollPosition = 0;			_textFlow.flowComposer.addController(cont);			_textFlow.addEventListener(CompositionCompleteEvent.COMPOSITION_COMPLETE, composeListener);			_textFlow.addEventListener(TextLayoutEvent.SCROLL, scrollTextFlow);			_textFlow.interactionManager = new SelectionManager();			_textFlow.flowComposer.updateAllControllers();		}		private function statusChangeHandler(e:StatusChangeEvent):void {			trace(e.status);			if (e.status == InlineGraphicElementStatus.LOADING)			{				graphicTotal++;				trace(graphicTotal);			}			// if the graphic has loaded update the display			// set the loaded graphic's height to match text height			if (e.status == InlineGraphicElementStatus.READY)			{				graphicLoaded++;				trace("Total vs. Loaded : "+graphicLoaded,graphicTotal);				_textFlow.flowComposer.updateAllControllers();			}			if (e.status == InlineGraphicElementStatus.SIZE_PENDING)			{				graphicSizing++;				trace("Total vs. Sizing : "+graphicSizing,graphicTotal);				_textFlow.flowComposer.updateAllControllers();			}			if (e.status == InlineGraphicElementStatus.ERROR)			{				trace(InlineGraphicElementStatus.ERROR);			}		}		private function composeListener(event:Event):void {			trace("composition complete");			if ((graphicLoaded==graphicTotal)&&(graphicSizing==graphicTotal))			{				_textFlow.flowComposer.updateAllControllers();				textHeight = updateSizeInfo();				trace(textHeight, textSpace.height);				if (textHeight > textSpace.height)				{					addSlider();					textSpace.addEventListener(ScrollEvent.SCROLL, updateText);					cont.verticalScrollPolicy = ScrollPolicy.ON;				}			}		}		private function updateSizeInfo():Number {			if (_textFlow)			{				var contTf:ContainerController = _textFlow.flowComposer.getControllerAt(0);				if (contTf.container)				{					//height of the TextFlow instance					var tH:int = Math.ceil(contTf.getContentBounds().height);					return tH;				}			}			return 0;		}		private function addSlider():void {			addChild(sl);			sl.name = "sl";			sl.x = myShape.width;			sl.y =.5*c;			sl.height = myShape.height-c;			//sl.scrollPosition = 0;			sl.maxScrollPosition = updateSizeInfo();			sl.addEventListener(ScrollEvent.SCROLL, updateText);		}		private function updateText(event:ScrollEvent):void {			trace("From ScrollEvent: "+event.position);			cont.verticalScrollPosition = Math.ceil((event.position/sl.height)*updateSizeInfo());		}		private function scrollTextFlow(event:Event):void {			var amountMove:int = (cont.verticalScrollPosition/textHeight);			trace("scrolling text: "+amountMove);		}		private function removedFromStage(event:Event):void {			trace("textArea removed");			_textFlow.removeEventListener(StatusChangeEvent.INLINE_GRAPHIC_STATUS_CHANGE,statusChangeHandler);			_textFlow.removeEventListener(CompositionCompleteEvent.COMPOSITION_COMPLETE, composeListener);			_textFlow.removeEventListener(TextLayoutEvent.SCROLL, scrollTextFlow);			_textFlow.flowComposer=null			_textFlow = null			if (this.getChildByName("sl")){				sl.removeEventListener(ScrollEvent.SCROLL, updateText);				sl=null				}			cont=null					}	}}